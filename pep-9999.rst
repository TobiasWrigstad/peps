PEP: 9999
Title: The FrankenPEP for Venice and BoC
Author: Matthew Johnson, Matthew Parkinson, Sylvan Clebsch, Tobias Wrigstad
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 16-Jun-2023
Python-Verson: TBD


Abstract
========

The PEP proposes an extension to Python with "Behaviour-oriented
Concurrency", a new concurrency model that is safe (in the sense
of being guaranteed to be free from data races) and does not 
require a GIL.

The PEP extends Python with several new concepts, most notably: 
*behaviours*, *regions* and *region objects*.

We divide objects into two categories, mutable and immutable. All
mutable objects in a program are divided into isolated regions. Each 
region is reified as a region object that allows explicit region
manipulation. Regions can be *shared* or *private*. Private regions
can be manipulated synchronously, whereas shared regions can be 
manipulated only asynchronously. A dynamic check ensures that  
the contents of a shared region is accessed by at most one running 
task at a time. Finally, a behaviour is a task that operates on
zero or more regions.

The isolation of regions ensure that accesses to objects are never
contended.

.. image:: pep-9999/overview.svg
  :alt: Overwiew of the moving pieces

While this picture may seem complicated, it contains everything 
we need to explain all aspects of this PEP.


Proposal
========

Summary:

* Add the new concept `behaviour`_ 
* Add the new concepts `region`_, `shared region`_, `private region`_ and `region object`_
* Add a new runtime component for scheduling and running behaviours
* Add new dynamic checking to enforce isolation

The following description first discusses the rationale for
adopting a new concurrency model in Python. The rest of the
description then takes a bottom-up approach. It starts by defining
regions and their reification in Python as region objects, and
operations on region objects. It then distinguishes private and
shared regions and introduces behaviours and how behaviours are
exposed to Python programmers in the form of the ``when`` language
construct.


Rationale
=========

Behaviour-oriented Concurrency (BoC for short) is a concurrency
model where programs are comprised of tasks that we call
*behaviours*. A behaviour only has access to immutable objects,
objects created inside the behaviour, objects inside regions
passed to the behaviour at the time of its creation, and objects
inside regions it captures from its enclosing lexical scope.

A region is a set of mutable objects. We refer to the reified set
as a *region object*. Regions do not overlap, so the intersection
of two regions is always empty. Furthermore, objects inside a
region can only be pointed to by other objects in the same region.

A region is either private or shared. Shared regions can form any
topology. Private regions always form a forest topology. If a
private region object is only referenced from stack variables or
from "its own objects", it is free, and has no enclosing 
region. If a private region is referenced from objects other than
its own, those objects must all be in the same region. We refer to
the directly enclosing region as the *parent region*. The forest topology
is enforced by dynamic checking.

Regions are created as private but may be shared using an explicit
operation. 

Accessing the contents of a region requires *opening* the region.
A private region can be opened synchronously. A shared region can
only be opened asynchronously by spawning a behaviour. The runtime
ensures that behaviours that open the same region never run at the
same time. Note that this means that accessing a nested region 
requries opening its parent region first.

Unlike e.g. a finish/async model, behaviours do not return values
or join at a particular program point. Such a model encourages a
fork/join style way of building programs, which have a hard time
saturating multicore machines due to Amdahl's law. In BoC,
programs "continue" by behaviours spawning more behaviours, and
coordination happens when behaviours operate on the same regions.

Spawning a behaviour can be likened with an asynchronous method
call to a method that has no return value, and whose arguments are
zero or more shared regions.

In order to transition from spawned to running, a behaviour needs
to *acquire* all its shared regions. (If the behaviour has no
parameter, it can transition to running immediately.) The runtime
ensures that only one behaviour at a time can acquire a shared
region. The implementation guarantees that multiple spawned
behaviours whose parameters include the same regions will not
deadlock, and that only one of such behaviours will be able to run
at a time.

Thus, inside a running behaviour, all accessible regions are
effectively private. In other words, the behaviour has exclusive
access to all mutable state that it can reach. Therefore, it
cannot race with concurrent behaviours.

When a behaviour finishes, it `releases`_ all shared regions so
that they can be acquired by other scheduled behaviours. (It is
not possible to manually release a region, nor to release it
before a behaviour finishes.)

One of the key features of BoC is that it allows happens-before
relations between behaviours to be expressed easily in a readable
way by tying it to program order and how regions are shared 
across behaviours. In combination with the data-race freedom from 
isolation, this makes it considerably easier to reason about 
concurrent programs, than less structured models. 


Concepts
========

Region
  A region is a set of objects that are only referenced from within the region,
  or from its region object.

Region object
  An object that reifies a region and permits manipulations of the entire region.

Implicitly created region
  A technical construct used under the hood to allow the creation of objects
  without an explicit owner. The idea is that an implicitly created region's
  membership can be merged with another region based on data-flow.
  (See `assignment and ownership`_.)
  
Behaviour
  A task that can access the memory of zero or more regions.

Owned
  Belonging to an *explicitly* created region (in the sense of being nested in).

Free
  Belonging to an *implicitly* created region. A programmer can think about this
  case as "there is no owner". 

Private
  Has at most one owner. Dual of shared.

Shared
  Ownership can be shared across multiple owners. Dual of private.

Owned object
  An object in an explicitly created region.

Free object
  An object in an implicitly created region.

Owned region
  A region that is nested inside another explicitly created region.

Free region
  A region that is a root in a region tree (nested in an implicitly created region).

Immutable object
  An object that cannot be mutated.

Open region
  A region whose objects are accessible to the program.

Closed region
  A region whose objects are inaccessible to the program.


Capsule Summary of Semantics
============================

All objects and regions are free and private on creation.
A free region or object can become *owned* by a(nother) region.

The following code creates a region and an object, opens the
region (see `region isolation`_), and makes the object owned by
the region::

  r = Region()   # closed, free and private
  o = object()   # free 
  with r:        # open r
    r.f = o      # o becomes owned by r

A *private region* can be turned into a *shared region*, but not
the other way around (see further `concurrency`_)::

  r = Region()
  r.make_shareable()

Objects are always private with the exception of region objects
for shared regions.

A region that is *private and owned* can become *private and free*
if all incoming references to its region object from the enclosing
region are deleted.


Topological Constraints
-----------------------

Objects in a region can only be referenced from within the region. 

A mutable object can only point to:

* objects in the same region,
* immutable objects, or
* region objects (of any region)

An immutable object can only point to other immutable objects.


Assignment and Ownership
------------------------

The following explains how assignment governs and is governed by
ownership. In particular, it explains how objects become owned by
regions, and how region nesting works. (1) and (2) are notes on
side-effects explained below.

Let ``x`` and ``y`` be objects and ``R`` be a region object.
Let ``region(x) == None`` mean that ``x`` is free.
Let ``region(x) == R`` mean that ``x`` is owned by ``R``.
Let ``regions(x,...,y)`` mean the set of regions, ``{ region(x), ..., region(y) }``.

The assignment ``x.f = y`` is legal (with respect to ownership) iff:

* ``regions(x,y) == { None }`` **(1)**, or
* ``regions(x,y) == { R }``, or
* ``regions(x,y) == { None, R }`` **(2)**
 
The assignment ``R.f = y`` is legal (with respect to ownership) iff:

* ``region(y) == R``, or
* ``region(y) == None`` **(2)**

The assignment ``x.f = R`` is legal (with respect to ownership) iff:

* ``R`` is a shared region, or
* ``region(x) == R``, or
* ``region(x) == None`` **(2)**, or
* ``region(x) == R'`` and ``R`` is owned by ``R'`` (aka nested in ``R'``), or
* ``region(x) == R'`` and ``R`` is free **(3)**

  
**Notes on side-effects:**

(1) Fusing implicit regions: As a side-effect, we merge these implicitly created regions into one implicitly created region.
(2) Converting implicit ownership to explicit: As a side-effect, we merge the implicitly created region into ``R``.
(3) Nesting: ``R`` becomes owned by ``R'``.

Any assignment that does not abide by the above rules will raise
an exception. Example::

  r1 = Region()
  r2 = Region()
  r3 = Region()
  with (r1, r2):
    r1.f = r3    # OK, r3 becomes owned by r1
    r2.f = r3    # Throws exception since r3 is already owned by r1

Here is a more elaborate example that allows some implicit merging::

  r1 = Region()
  r2 = Region()
  with (r1, r2):
    o1 = object() # free object
    o2 = object() # free object
    o1.f = o2     # o1 and o2 are in the same implicit region
    r1.f = o1     # o1 becomes owned by r1, as does o2
    r2.f = o2     # Throws an exception as o2 is in r1

**TODO** Check the following, and add implicit(R):

  To prevent cyclical region topologies, when we do ``R.f = R'``,
  where ``R'`` is **not** shared, we have to do two things:
  
  * Ensure that ``region(r2) == None``
  * Walk the ownership chain of ``r1`` until we find
    shared or free region, and if that top level region is free, it
    cannot be ``r2``. I think that's sufficient?

    
Region Isolation
----------------

A region is either **open** or **closed**. When created, a region
is always closed. When a region is closed, its
objects cannot be accessed by the program. To make the objects
accessible, the region must be opened using a ``with`` block on its
region object::

  r = Region()     # creates new empty region object
  ...              # r is closed
  with r:
    # r is open
    r.f = object() # we can write to the region etc.
  ...              # r is closed at with's end
  print(r.f)       # will throw exception

It is possible to open multiple regions in a single hit::

  with (r1, r2):
    ... # r1 and r2 are both open

As a consequence of this design, if region ``r2`` is nested in
region ``r1``, in order to access and open ``r2``, one first
must open ``r1``.


Region-Wide Operations
----------------------

Merge
  An operation that moves all objects in a region into another region.

Freeze
  An operation that makes all objects in a region immutable.

Via the region object it is possible to operate on an entire region.


Freezing Regions
~~~~~~~~~~~~~~~~

A region ``R`` can be frozen if it is free, private, and closed.
Freezing a region makes its owned objects immutable (and free),
and ``R`` becomes empty. Freezing affects owned regions as well as
their contained objects (i.e. it is deep)::

  r2 = Region("r2")
  r3 = Region("r3")
  with r2:
    r2.field = [47, r3]
    with r3:
      r3.field = 11
  x = r2.freeze()

The resulting value in ``x`` is the list ``[47, 11]`` stored in
``r2``, with the frozen content of the nested region ``r3``
as the second element. As a side-effect of the above, the region
objects ``r2`` and ``r3`` become empty and free.

Freezing an open region raises a ``FreezeException``.

Note that freezing avoids several of the problems that led to
the `rejection <https://mail.python.org/pipermail/python-dev/2006-February/060793.html>`_ 
of `PEP 351 <https://peps.python.org/pep-0351/>`_:

- The side-effects of freezing a region are known because the 
  region is isolated
- You only freeze a closed region, meaning there are no variables
  etc. that can reach the contents of the region and can witness
  the change in mode
- Freezing is in-place, not by copy


Merging Regions
~~~~~~~~~~~~~~~

A free region ``R`` can be merged into an open region
``R'``. This changes the ownership of all objects in ``R`` from ``R`` to
``R'``, and ``R`` becomes empty. Merging affects directly nested
regions by changing their ownership to the new region. It does not
affect its containing objects or indirectly nested regions (i.e.
it is shallow). Example::

  x = r2.merge(r1)

The code above *moves* all objects in ``r2`` into ``r1``. The
variable stores an object (owned by ``r1``) with a copy of all
fields in ``r2``.

After merging, the ``r2`` region behaves as if it was an alias
to ``r1``. 


Concurrency
-----------

So far, all regions we have discussed were private, meaning they
were only accessible to the current behaviour (think: "thread of
control"). To make a region accessible to multiple behaviours, it
must first be explicitly turned into a shared region::

  r = Region()
  ...
  r.make_sharable()   # placeholder syntax

Only regions which are *free and closed* can be made shared.

After a region has been made shared, its region object can be
referenced freely from other regions. This can be interpreted as
shared ownership. To coordinate accesses under shared ownership,
we need an asynchronous version of the ``with`` construct, which we
call ``when``. A ``when`` can operate on zero or more regions, which
must all be shared::

  r1 = Region()
  r1.make_sharable()
  r2 = Region()
  r2.make_sharable()
  when (r1, r2):
    ... # r1 and r2 are open

We can think of ``when`` as enforcing that ``r1`` and ``r2`` are
effectively private inside the ``when`` block through a dynamic
check. To emphasise the asynchronous nature of a ``when`` talk
about a ``when`` block as **spawning** a **behaviour**. This
language is meant to convey the dynamic creation of a behaviour
which is registered in the runtime, and which is runnable once it
has **acquired** (established exclusive access to) its shared
region parameters. Thus, code that follows a behaviour (a ``when``
block) may run concurrently with it::

  r = Region()
  when r:
    print("A")
  print("B")

In the above example, the program may output both "AB" and "BA".
See more under `ordering behaviours`_ below.

A behaviour can be thought of as a task with a set of regions that must
be acquired by the runtime before the task can run. A behaviour
has no return value. In additional to the regions it acquires, a 
behaviour may access immutable objects and other shared regions.

We refer to behaviours whose regions are overlapping as *overlapping
behaviours*. The runtime guarantees that overlapping behaviours are
serialised.

A behaviour can capture regions in the enclosing scope if they
are free, private and closed::

  r = Region()        # free, private and closed
  when ():            # immediately runnable
    ... r ...         # r is accessible and closed
  ...                 # opening r or aliases to r throw exception
    
Because a ``when`` can operate on any number of shared regions, it
can be used to establish safe synchronous action to different
state at different times (similar to grabbing different sets of
locks, but without risking deadlocks, and with a guarantee that
anything that can be accessed is actually protected by a lock that
has been successfully acquired)::

  my_account = Region()
  your_account = Region()

  with (my_account, your_account):
    my_account.balance = 100
    your_account.balance = 0

  my_account.make_sharable()
  your_account.make_sharable()

  # transfer money between two accounts
  when (my_account, your_account) as (m, y):
    m.balance, y.balance = y.balance, m.balance


Ordering Behaviours
~~~~~~~~~~~~~~~~~~~

The program order of spawns of overlapping behaviours controls the 
happens-before relation between them. In the following example, 
behaviour *b1* is guaranteed to run before *b2* but not before *b3*::

  when (c1, c2):   # b1
    ... 

  when (c2):       # b2
    ...

  when (c3):       # b3, does not overlap with b1 or b2
    ...

To ensure that *b3* does not run before *b1*, we can either introduce
a temporary shared region to make them overlapping::

  c4 = Region().make_shareable() # Empty region
  when (c1, c2, c4):   # b1
    ... 

  when (c2):           # b2 -- can run as soon as b1 finishes
    ...

  when (c3, c4):       # b3 -- can run as soon as b1 finishes
    ...


or we can spawn *b3* at the end of *b1*::

  when (c1, c2):   # b1
    ... 
    when (c3):     # b3
      ...

  when (c2):       # b2
    ...

Note that program order refers to order of execution in a single 
behaviour. In the following case, *b2* may run before or after *b4*::

  c = Region("r").make_shareable()
  when ():     # b1
    when (c1): # b2
      ...

  when ():     # b3
    when (c1): # b4
      ...


Making a Shared Region Private Again
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  **TODO** Even more WIP!

It is not possible to make a shared region private again. However, it is
possible to spawn a behaviour that, once it has dynamically established
that is has exclusive access to the shared region, moves all its contents
to a private region.

For now, assume that it is possible to call a method
``detach_all()`` on a shared region to create a new private region
that holds all the contents of the shared region, which becomes
empty.

The following code spawns a behaviour that swaps the contents of two
regions::

  when (c1, c2):
    r1, r2 = c1.detach_all(), c2.detach_all()
    c2.field = c2.merge(r1)
    c1.field = c1.merge(r2)



.. _immutable:

Immutable Objects
-----------------

An immutable object's observable state cannot be changed.
(Unobservable state such as its reference count can change.)
An immutable object may only reference other immutable objects.

All attempts to change an immutable object, e.g. a write to a
field, will raise a ``ImmutabilityException``, and the object will
be left unchanged.


Integration with Existing Python Code
-------------------------------------

**TODO**  This is WIP!

The region system is designed to work well with existing code.
If you don't use regions, then all the objects will be in implicit regions, and these regions
will be combined as necessary, so no errors would be introduced.  This means existing python code
that is passed objects from at most one explicit region will not introduce RegionIsolationExceptions.

The concurrency model will require a GIL per scheduler thread for interaction with existing legacy code. 
That is each scheduler thread would be a sub-interpreter.
This could be relaxed in the future as more understanding is developed.

Global and module level variables will be in a special global region.  This region will taint
anything that it points to, to also be global.  This will be used to trap races on globals from multiple
behaviours. 


Glossary
========

.. _region:

region
  A set of mutable objects including a region object.

.. _private region:

private region
  A region that is only accessible to one behaviour. 

.. _region object:

region object
  A single instance of the class ``Region`` that acts as a 
  frontend for a region.

root or root field
  A field in a region object that holds a mutable object in
  the region. Access to a region's root field requires that
  the region is open.

open region
  A region r is open if there is a `with r` block on the 
  stack. An open region can grown (new objects allocated in
  the region), shring (objects in the region are deallocated),
  and read and written.

closed region
  Objects in a closed region are not accessible to the program 
  without first opening the region. 

.. _shared region:

shared region
  A region whose ownership is/can be shared by multiple other regions.

region set
  The set of regions that must be acquired by a behaviour in order
  for it to run.

.. _behaviour:
.. _behaviours:

behaviour
  An asynchronous task spawned through a ``when`` block. It is
  passed zero or more shared regions that we call its region set.
  Once these regions have been acquired the behaviour is ready to
  run. Once the behaviour is finished, all the regions in its
  region set are released.
  
happens-before relation
  TODO

.. _acquire:
.. _release:
.. _releases:

acquire and release 
  A behaviour implicitly acquires all regions in its region set before
  transitioning to the running state. The runtime ensures that
  acquisition is deadlock and livelock free.



Open Questions
==============

- What is the semantics of opening? order? nesting?
- How do we ensure that an object isn't stored in a local variable whose lifetime is longer than the open-scope of its region?
- Merging, freezing and nesting is sound because we only allow a region object to be referenced from one field
- Can an immutable object have a mutable class?
- What about cycles between regions?
- Can we store regions in imms? (I say NO!)
- What is the story for swapping contents of two shared regions
