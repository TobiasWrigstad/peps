PEP: 9999
Title: Deep Immutability in Python
Author: Matthew Johnson <matjoh@microsoft.com>, Matthew Parkinson <mattpark@microsoft.com>, Sylvan Clebsch <sylvan.clebsch@microsoft.com>, Fridtjof Peer Stoldt <fridtjof.stoldt@it.uu.se>, Tobias Wrigstad <tobias.wrigstad@it.uu.se>
Sponsor: TBD
Discussions-To: TBD
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 27-Feb-2025
Python-Version: 3.12
Post-History: 
Resolution:


Abstract
========

This PEP proposes adding a mechanism for deep immutability to
Python via a new builtin function ``freeze(obj)``. This function
takes a reference to an object and recursively renders the object
and all objects it references immutable. (This is *deep*
immutability --- just making the first object immutable is called
*shallow* immutability.)

Deep immutability will provide stronger guarantees against
unintended modifications, improving correctness, security, and
parallel execution safety.

In this PEP, we rely
on the GIL to ensure the correctness of reference counts of 
immutable objects, but we have several planned memory management 
extensions.

Immutability in action:

.. code-block:: python

	class Foo: pass

	f = Foo()
	g = Foo()
	h = Foo()

	f.f = g
	g.f = h
	h.f = g # cycle!

	g.x = "African Swallow" # OK
	freeze(f) # Makes, f, g and h immutable
	g.x = "European Swallow" # Throws immutability exception


Motivation
==========


Ensuring Data Integrity
-----------------------

Python programs frequently manipulate large, interconnected data
structures such as dictionaries, lists, and user-defined objects.
Unintentional mutations can introduce subtle and
difficult-to-debug errors. By allowing developers to explicitly
freeze objects and their transitive dependencies, Python can
provide stronger correctness guarantees for data processing
pipelines, functional programming paradigms, and API boundaries
where immutability is beneficial.


Eliminating Data Races in Concurrent Code
-----------------------------------------

Pythonâ€™s Global Interpreter Lock (GIL) mitigates many data race
issues, but as Python evolves towards improved multi-threading and
parallel execution (e.g., subinterpreters and free-threaded Python
efforts), data races on shared mutable objects become a more
pressing concern. A deep immutability mechanism ensures that
shared objects are not modified concurrently, enabling safer
multi-threaded and parallel computation.

See also the discussion about extensions further down in this
document.


Optimisations and Caching Benefits
----------------------------------

Immutable objects provide opportunities for optimisation, such as
structural sharing, memoization, and just-in-time (JIT)
compilation techniques (specialising for immutable data, e.g.
fixed shape, fewer barriers, inlining, etc.). Freezing objects can
allow Python to implement more efficient caching mechanisms and
enable compiler optimisations that rely on immutability
assumptions. This PEP will permit such opportunities to go
beyond today's immutable objects (like ``int``, ``string``) and
shallow immutable objects (``tuple``, ``frozenset``).



Specification
=============

Changes to Python objects
-------------------------

Every Python object will have a flag that keeps track of its
immutability status. Details about the default value of
this flag is discussed further down in this document. 

The flag can be added without extending the size of the
Python object header. We initially intend for this flag 
to be implemented by bit-stealing from the reference 
counter, but this will change in our planned extensions.


Implementation of Immutability
------------------------------

Immutability is enforced through run-time checking. The macro
``Py_CHECKWRITE(op)`` is inserted on all paths that are guaranteed
to end up in a write to ``op``. The macro inspects the immutability
flag in the header of ``op`` and signals an error if the immutability
flag is set.

A typical use of this check looks like this:

.. code-block:: c

	if (!Py_CHECKWRITE(op)) {        // perform the check
	    PyErr_WriteToImmutable(op);  // raise the error if the check fails
	    return NULL;                 // abort the write
	}  
	... // code that performs the write


As writes are common but lack a common path that most writes to through
the PEP requires a ``Py_CHECKWRITE`` call, there are several places in
the CPython code base that are changed as a consequence of this PEP.
So far we have identified around 70 writes spread across a dozen files.


New Obligations on C Extensions
-------------------------------

Because our implementation builds on information available to the CPython
cycle detector, types defined through C code will support immutability 
"out of the box".

C extensions that perform writes to data which can be made immutable
should add the ``Py_CHECKWRITE`` macro shown above on all paths in the
code that lead to writes to that data. If C extensions manage their
data through Python dictionary objects, no changes are needed.

**TODO**
  If we don't have a way to tell whether or not an extension 
  supports immutability, then freeze might end up "leaking"
  mutable data. Let's discuss this.

We are discussing adding a ``__freeze__`` hook that will be called 
after an object has been made immutable. This hook could then be used 
to freeze or otherwise manage any other state on the side that is
introduced through a C-extension.

	@MattJ: Something about adding a dummy node to the object graph
	that the freeze function finds.


Freezing Type Which are Not Immutability-Aware
----------------------------------------------

**TODO** Decide what happens when we attempt to freeze an
object and discover an object which is not immutability-aware.

1. Throw an exception
2. Leave it and live with the unsoundness
3. Nullify the reference to the non immutability-aware object
4. ...

Somewhere we should also talk about what happens if we throw
an error during freezing. Do we leave some structures partially
frozen? If we don't want that, we need to save a log of things
to unfreeze in case of an error.


Examples of Uses of CHECKWRITE
------------------------------

Inspiration and examples can be found by looking at existing
uses of ``Py_CHECKWRITE`` in the CPython codebase. Two good
starting places are ``object.c`` and ``dictobject.c``.


Deep Freezing Semantics
-----------------------

The ``freeze(obj)`` builtin function works as follows:

1. It recursively marks ``obj`` and all objects reachable from ``obj``
   immutable.
2. If ``obj`` is already immutable (e.g., an integer, string, or a
   previously frozen object), it is a no-op.
3. The freeze operation follows object references (relying on ``tp_traverse`` 
   in the type structs of the objects involved), including:

    * Object attributes (``__dict__`` for user-defined objects,
      ``tp_dict`` for built-in types).
    * Container elements (e.g., lists, tuples, dictionaries,
      sets).
    * The ``__class__`` attribute of an object (which makes freezing
      instances of user-defined classes also freeze their class
      and its attributes).
    * The ``__bases__`` chain in classes (freezing a class freezes its
      base classes).

5. Attempting to mutate a frozen object raises an exception (``MutationError``).


Default (Im)Mutabiliy 
---------------------

- TODO: describe what classes create immutable objects

- (Interned) strings, numbers, and tuples of immutable objects create immutable
  objects by default


Consequences of Deep Freezing
=============================

* Class Freezing: Freezing an instance of a user-defined class
  will also freeze its class, potentially affecting all instances
  of that class.
* Metaclass Freezing: Since class objects have metaclasses,
  freezing a class may propagate upwards through the metaclass
  hierarchy.
* Global State Impact: Freezing an object that references global
  state (e.g., ``sys.modules``, built-in types) could inadvertently
  freeze critical parts of the interpreter.

As the above list shows, a side-effect of freezing an object is
that its type becomes frozen too. Consider the following program,
which is not legal in this PEP because it modifies the type of an
immutable object:

.. code-block:: c

	class Counter:
	  def __init__(self, initial_value):
	    self.value = initial_value
	  def inc(self):
	    self.value += 1
	  def dec(self):
	    self.value -= 1
	  def get(self):
	    return self.value

	c = Counter(0)
	c.get() # returns 0 
	freeze(c) # (1)
	... 
	Counter.get = lambda self: 42 # OK in CPython 3.12, throws exception with this PEP
	c.get() # returns 42, even though c was frozen when the value was 0!

With this PEP, the code above throws an exception on
Line (1) because the type object for the ``Counter`` type
is immutable. Our freeze algorithm takes care of this as
it follows the class reference from ``c``. If we did not
freeze the ``Counter`` type object, the above code would
work and the counter will *appear* to be mutable because
of the change to its class. 

The dangers of not freezing the type is apparent when considering
avoiding data races in a concurrent program. If a frozen counter
is shared between two threads, the threads are still able to
race on the ``Counter`` class type object.

As types are frozen, this problem is avoided. Note that
freezing a class needs to freeze its superclasses as well.


Subclassing Immutable Classes
-----------------------------

CPython classes hold references to their subclasses.
If immutability it taken literally, it would not be
permitted to create a subclass of an immutable type.
Because this reference is "accidental" and does not
get exposed to the programmer in any dangerous way,
we permit frozen classes to be subclassed (by mutable
classes). C.f. `Sharing Immutable Data Across Subinterpreters`_.


Implementation Details
======================

1. Introduce an ``is_immutable`` flag on objects to capture whether or
   not they are frozen. The status is accessible through ``_Py_ISIMMUTABLE``
	in the C API and in Python code through the ``isimmutable`` builtin.
2. Modify object mutation operations (``PyObject_SetAttr``,
   ``PyDict_SetItem``, ``PyList_SetItem``, etc.) to check the 
   flag and raise an error when appropriate.
3. Implement ``freeze(obj)``, ensuring it traverses object references
   safely, including cycle detection.

**TODO** Do we need the ``freezeglobals()``?


Backward Compatibility
======================

This proposal is fully backward-compatible, as no existing Python
code will be affected unless it explicitly calls ``freeze(obj)``.
Frozen objects will raise errors only when mutation is attempted.


Performance Implications
========================

The cost of checking for immutability violations is
an extra dereference of checking the flag on writes.
There are implementation-specific issues, such as
various changes based on how and where the bit is stolen.


Alternatives Considered
=======================

1. Shallow Freezing: Only mark the top-level object as immutable.
   This would be less effective for ensuring true immutability
   across references. In particular, this would not make it safe
   to share the results of ``freeze()`` across threads without risking
   data-race errors. Shallow immutability is not strong enough to support 
   sharing immutable objects across subinterpreters (see extensions).
2. Copy-on-Write Immutability: Instead of raising errors on
   mutation, create a modified copy. However, this changes object
   identity semantics and is less predictable. Support for copy-on-write
   may be added later, if a suitable design can be found.
3. Immutable Subclasses: Introduce ImmutableDict, ImmutableList,
   etc., instead of freezing existing objects. However, this does
   not generalize well to arbitrary objects and adds considerable
   complexity to all code bases.
4. Deep freezing immutable copies as proposed in `PEP 351: The 
   freeze protocol <https://peps.python.org/pep-0351/>`_. That PEP
   is the spiritual ancestor to this PEP which tackles the
   problems of the ancestor PEP and more (e.g. meaning of
   immutability when types are mutable, immortality, etc).


Open Issues
===========

1. How does deep freezing interact with weak references?
2. Freezing global state
3. Freezing function objects and lambdas


Future Extensions
=================

This PEP is the first in a series of PEPs with the goal of delivering
a Data-Race Free Python that is theoretically compatible with, but 
notably not contigent on, `PEP 703`_ -- despite delivering 
multicore performance in Python.

This work will take place in the following discrete steps:

1. Atomic reference counting of immutable objects to permit 
   concurrent increments and decrements on shared object RC's.
2. Support for managing cyclic immutable data using reference
   counting.
3. Support for sharing immutable data across subinterpreters. 
4. Support for sharing mutable data across subinterpreters,
   with dynamic ownership protecting against data races.
5. Support for behaviour-oriented concurrency.


Support for Atomic Reference Counting
-------------------------------------

As preparation for the extension `Sharing Immutable Data Across Subinterpreters`_,
we will add support for atomic reference counting for immutable objects. This
will complement work in `Simplified Garbage Collection for Immutable Object Graphs`_,
which aims to make memory management of immutable data more efficient.

When immutable data is shared across threads we must ensure that 
concurrent reference count manipulations are correct, which in turns
requires atomic increments and decrements. Note that since we are only
planning to share immutable objects across different GIL's, it is
*not* possible for two threads to read--write or write--write race
on a single field. Thus we only need to protect the reference counter
manipulations, avoiding most of the complexity of `PEP 703`_


Simplified Garbage Collection for Immutable Object Graphs
---------------------------------------------------------

In `previous work <https://dl.acm.org/doi/10.1145/3652024.3665507>`_,
we have identified that objects that make up cyclic immutable
garbage will always have the same lifetime. This means that a
single reference count could be used to track the lifetimes of
all the objects in such a strongly connected component (SCC).

We plan to extend the freeze function with a SCC analysis that
creates a designated (atomic) reference count for the entire
SCC, such that reference count manipulations on any object in
the SCC will be "forwarded" to that shared reference count.
This can be done without bloating objects by repurposing the
existing reference counter data to be used as a pointer to
the shared counter.

This technique permits handling cyclic garbage using plain
reference counting, and because of the single reference count
for an entire SCC, we will detect when all the objects in the
SCC expire at once.


Sharing Immutable Data Across Subinterpreters
---------------------------------------------

We plan to extend the functionality of `multiple subinterpreters <https://peps.python.org/pep-0734/>`_
to *share* immutable data without copying. This is safe and
efficient as it avoids the copying or serialisation when
objects are transmitted across subinterpreters.

This change will require reference counts to be atomic (as
discussed above) and the subclass list of a type object to
be made thread-safe. Additionally, we will need to change
the API for getting a class' subclasses in order to avoid
data races.

This change requires modules loaded in one subinterpreter to be
accessible from another. Implementation details here are to be
discussed, but the version we have been working on is one in which
a side effect of calling ``freezeglobals()`` is that all
subsequent module imports are imported into the main
module and immediately frozen and shared across all subinterpreters.

**TODO** Sync the above with the discussion about freezeglobals.


Data-Race Free Python
---------------------

While useful on their own, all the changes above are building
blocks of Data-Race Free Python. Data-Race Free Python will
borrow concepts from ownership (namely region-based ownership,
see e.g. `Cyclone <TODO>`_) to make Python programs data-race free
by construction. Which will permit multiple subinterpreters to
share *mutable* state, although only one subinterpreter at a time
will be able to access (read or write) to that state. In theory,
this work could also be authored on-top of free-theaded Python (PEP 703).

Data-Race Free Python is different from `PEP 703`_ which
aims to make the CPython run-time resilient such that it does
not crash if a Python program contains data-races. As is evident
from the work on this PEP, considerable complexity is necessary
to protect the integrity of the interpreter against accidental
violations in poorly synchronised programs. Data-Race Free Python
on the other hand will permit the Python runtime to retain a lot
of its simplicity because --- just like today --- the interpreter
can safely assume that data-races will not happen, even if we
(effectively) the GIL.


Reference Implementation
========================

`Available here <https://github.com/mjp41/cpython/pull/51>`.


References
==========

* `PEP 703`_
* `PEP 351: The freeze protocol <https://peps.python.org/pep-0351/>`_
* https://peps.python.org/pep-0734/
* https://peps.python.org/pep-0683/

.. _PEP 703: https://peps.python.org/pep-0703
