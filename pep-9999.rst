PEP: 9999
Title: The FrankenPEP for Venice and BoC
Author: Matthew Johnson, Matthew Parkinson, Sylvan Clebsch, Tobias Wrigstad
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 16-Jun-2023
Python-Verson: TBD


Abstract
========

The PEP proposes an extension to Python with "Behaviour-oriented
Concurrency", a new concurrency model that is safe (in the sense
of being guaranteed to be free from data races) and does not 
require a GIL.

The PEP extends Python with several new concepts, most notably: 
*behaviours*, *regions* and *region objects*.

We divide objects into two categories, mutable and immutable. All
mutable objects in a program are divided into isolated regions. Each 
region is reified as a region object that allows explicit region
manipulation. Regions can be *shared* or *private*. Private regions
can be manipulated synchronously, whereas shared regions can be 
manipulated only asynchronously. A dynamic check ensures that  
the contents of a shared region is accessed by at most one running 
task at a time. Finally, a behaviour is a task that operates on
zero or more regions.

The isolation of regions ensure that accesses to objects are never
contended.

.. image:: pep-9999/overview.svg
  :alt: Overwiew of the moving pieces

While this picture may seem complicated, it contains everything 
we need to explain all aspects of this PEP.


Proposal
========

Summary:

* Add the new concept `behaviour`_ 
* Add the new concepts `region`_, `shared region`_, `private region`_ and `region object`_
* Add a new runtime component for scheduling and running behaviours
* Add new dynamic checking to enforce isolation

The following description first discusses the rationale for
adopting a new concurrency model in Python. The rest of the
description then takes a bottom-up approach. It starts by defining
regions and their reification in Python as region objects, and
operations on region objects. It then distinguishes private and
shared regions and introduces behaviours and how behaviours are
exposed to Python programmers in form of the ``when`` language
construct.


Rationale
=========

Behaviour-oriented Concurrency (BoC for short) is a concurrency
model where programs are comprised of tasks that we call
*behaviours*. A behaviour only has access to immutable objects,
objects created inside the behaviour, and objects inside regions
passed to the behaviour at the time of its creation.

A region is a set of mutable objects. We refer to the reified set
as a *region object*. Regions do not overlap, so the intersection
of two regions is always empty. Furthermore, objects inside a
region can only be pointed to by other objects in the same region.

A regions is either private or shared. Shared regions can form any
topology. Private regions always form a forest topology. If a
private region object is only referenced from stack variables or
from "its own objects", it is *free*, and has no enclosing 
region. If a private region is referenced from objects other than
its own, those objects must all be in the same region. We refer to
the directly enclosing region as the *parent region*. The forest topology
is enforced by dynamic checking.

Regions are created as private but may be shared using an explicit
operation. 

Accessing the contents of a region requires *opening* the region.
A private region can be opened synchronously. A shared region can
only be opened asynchronously by spawning a behaviour. The runtime
ensures that behaviours that open the same region never run at the
same time. 

Unlike e.g. a finish/async model, behaviours do not return values
or join at a particular program point. Such a model encourages a
fork/join style way of building programs, which have a hard time
saturating multicore machines due to Amdahl's law. In BoC,
programs "continue" by behaviours spawning more behaviours, and
coordination happens when behaviours operate on the same regions.

Spawning a behaviour can be likened with an asynchronous method
call to a method that has no return value, and whose arguments are
zero or more shared regions.

In order to transition from spawned to running, a behaviour needs
to *acquire* all its shared regions. (If the behaviour has no
parameter, it can transition to running immediately.) The runtime
ensures that only one behaviour at a time can acquire a shared
region. The implementation guarantees that multiple spawned
behaviours whose parameters include the same regions will not
deadlock, and that only one of such behaviours will be able to run
at a time.

Thus, inside a running behaviour, all accessible regions are
effectively private. In other words, the behaviour has exclusive
access to all mutable state that it can reach. Therefore, it
cannot race with concurrent behaviours.

When a behaviour finishes, it `releases`_ all shared regions so
that they can be acquired by other scheduled behaviours. (It is
not possible to manually release a region, nor to release it
before a behaviour finishes.)

One of the key features of BoC is that it allows happens-before
relations between behaviours to be expressed easily in a readable
way by tying it to program order and how regions are shared 
across behaviours. In combination with the data-race freedom from 
isolation, this makes it considerably easier to reason about 
concurrent programs, than less structured models. 


Concepts
========

  **TODO** Is the region object in the region or not? Sometimes
  the writing is as it it is (e.g. can reference all its objects)
  and sometimes not (it can be referenced from outside the region).


Region
  A region is a set of objects that are only referenced from within the region.

Region object
  An object that reifies a region and permits manipulations of the entire region.

Behaviour
  A task that can access the memory of zero or more regions.

Owned
  Belonging to region (in the sense of being nested in).

Free
  Belonging to nothing.

Private
  Has at most one owner.

Shared
  Ownership can be shared across multiple owners.

Free object
  An object that does not belong to a region.

Owned object
  An object in a region.

Free region
  A region that is a root in a region tree.

Owned region
  A region that is nested inside another.

Immutable object
  An object that cannot be mutated.

Open region
  A region whose objects are accessible to the program.

Closed region
  A region whose objects are inaccessible to the program.


Capsule Summary of Semantics
============================

  **TODO** Missing the integration with "legacy" Python. Need to
  either give a good explanation of how that works, or explicitly
  delimit ourselves at this point.


All objects and regions are free and private on creation.
A free region or object can become *owned* by a(nother) region.

A *private region* can be turned into a *shared region*, but not the other way around.
Objects are always private with the exception of region objects for shared regions.

A region that is *private and owned* can become *private and free*
if all incoming references to its region object from the enclosing
region are deleted.


Topological Constraints
-----------------------

Objects in a region can only be referenced from within the region. 

  **TODO:** Missing Matt's implicit(R)


An *owned object* can only point to:

* *owned objects* in the same region,
* *immutable objects*, or
* region objects (of any region)

A *free object* can point to anything.

  **TODO** Note legacy objects.

An *immutable object* can only point to other immutable objects.


Assignment and Ownership
------------------------

The following explains how assignment governs and is governed by
ownership. In particular, it explains how objects become owned by
regions, and how region nesting works. (1) and (2) are notes on
side-effects explained below.

Let ``x`` and ``y`` be non-region objects, and ``R`` be a region object.
Let ``region(x) == None`` mean that ``x`` is free.
Let ``region(x) == R`` mean that ``x`` is *owned* by ``R``.

The assignment ``x.f = y`` is legal iff:

* ``region(x) == region(y)``, or
* ``region(x) == None``, or
* ``region(x) == R`` and ``region(y) == None`` **(1)**
 
The assignment ``R.f = y`` is legal iff:

* ``region(y) == R``, or
* ``region(y) == None`` **(1)**

The assignment ``x.f = R`` is legal iff:

* ``region(x) == R``, or
* ``region(x) == None``, or
* ``region(x) == R'`` and ``R`` is *owned* by ``R'``, or
* ``region(x) == R'`` and ``R`` is free **(2)**
 
**Notes on side-effects:**

(1) ``y`` and all free objects reachable from it become *owned* by ``R``.
    If we find an *owned* object that is *owned* by something other
    than ``R`` when scanning ``y``, the operation raises an exception.
(2) ``R`` becomes *owned* by ``R'``.

Any assignment that does not abide by the above rules will raise
an exception. Example::

  r1 = Region()
  r2 = Region()
  r3 = Region()
  with (r1, r2):
    r1.f = r3    # OK, r3 becomes owned by r1
    r2.f = r3    # Throws exception since r3 is already owned by r1

    
Region Isolation
----------------

  **TODO:** References to implicit(R)

A region is either **open** or **closed**. When created, a region
is always closed. When a region is closed, its
objects cannot be accessed by the program. To make the objects
accessible, the region must be opened using a ``with`` block on its
region object::

  r = Region()     # creates new empty region object
  ...              # r is closed
  with r:
    # r is open
    r.f = object() # we can write to the region etc.
  ...              # r is closed at with's end
  print(r.f)       # will throw exception

It is possible to open multiple regions in a single hit::

  when (r1, r2):
    ... # r1 and r2 are both open


Enforcing Region Isolation
~~~~~~~~~~~~~~~~~~~~~~~~~~

  **TODO** Update code example with implicit(R).

Region isolation is enforced by runtime checking. A write to a
field will raise an exception if the object stored in the field
belongs to another region (etc, see `assignment and ownership`_).
The following code sketches how isolation could be implemented
using ``__setattr__``::
  
   def __setattr__(self, attr_name, value):
     if region(self) == region(value) or \
       is_region_obj(value) or \
       is_immutable(value):
       object.__setattr__(self, attr_name, value) # perform update!
     else:
       raise RegionIsolationError()
    

Region-Wide Operations
----------------------

Merge
  An operation that moves all objects in a region into another region.

Freeze
  An operation that makes all objects in a region immutable.

Via the region object it is possible to operate on an entire region.
We already saw some examples of that in `assignment and ownership`_.


Freezing Regions
~~~~~~~~~~~~~~~~

A private closed region ``R`` can be frozen. This makes its
owned objects immutable (and free), and ``R`` becomes empty.
Freezing affects owned regions as well as their contained objects
(i.e. it is deep)::

  r2 = Region("r2")
  r3 = Region("r3")
  with r2:
    r2.field = [47, r3]
    with r3:
      r3.field = 11
  x = r2.freeze()

The resulting value in ``x`` is the list ``[47, 11]`` stored in
``r2``, with the frozen content of the nested region ``r3``
as the second element. As a side-effect of the above, the region
objects ``r2`` and ``r3`` become empty and free.

Freezing an open region raises a ``FreezeException``.

Note that freezing avoids several of the problems that led to
the `rejection <https://mail.python.org/pipermail/python-dev/2006-February/060793.html>`_ 
of `PEP 351 <https://peps.python.org/pep-0351/>`_:

- The side-effects of freezing a region are known because the 
  region is isolated
- You only freeze a closed region, meaning there are no variables
  etc. that can reach the contents of the region and can witness
  the change in mode
- Freezing is in-place, not by copy


Merging Regions
~~~~~~~~~~~~~~~

A region ``R`` can be merged into an open region
``R'``. This changes the ownership of all objects in ``R`` from ``R`` to
``R'``, and ``R`` becomes empty. Merging does affect directly nested
regions by changing their ownership to the new region. It does not
affect its containing objects or indirectly nested regions (i.e.
it is shallow). Example::

  x = r2.merge(r1)

The code above *moves* all objects in ``r2`` into ``r1``. The
variable ``x`` is a list (if necessary) of all the contents of all
variables in ``r2``. The list itself is in the ``r1`` region.

After merging, the ``r2`` region still exists but is empty --
all its fields are ``None`` etc.


Concurrency
-----------

So far, all regions we have discussed were private, meaning they
were only accessible to the current behaviour (think: "thread of
control"). To make a region accessible to multiple behaviours, it
must first be explicitly turned into a shared region::

  r = Region()
  ...
  r.make_sharable()   # placeholder syntax

Only regions which are *free and closed* can be made shared.

After a region has been made shared, its region object can be
referenced freely from other regions. This can be interpreted as
shared ownership. To coordinate accesses under shared ownership,
we need an asynchronous version of the ``with`` construct, which we
call ``when``. A ``when`` can operate on zero or more regions, which
must all be shared::

  r1 = Region()
  r1.make_sharable()
  r2 = Region()
  r2.make_sharable()
  when (r1, r2):
    ... # r1 and r2 are open

We can think of ``when`` as enforcing that ``r1`` and ``r2`` are
effectively private inside the ``when`` block through a dynamic
check. To emphasise the asynchronous nature of a ``when`` talk
about a ``when`` block as **spawning** a **behaviour**. This
language is meant to convey the dynamic creation of a behaviour
which is registered in the runtime, and which is runnable once it
has **acquired** (established exclusive access to) its shared
region parameters. Thus, code that follows a behaviour (a ``when``
block) may run concurrently with it::

  r = Region()
  when r:
    print("A")
  print("B")

In the above example, the program may output both "AB" and "BA".
See more under `ordering behaviours`_ below.

A behaviour can be thought of as a task with a set of regions that must
be acquired by the runtime before the task can run. A behaviour
has no return value. In additional to the regions it acquires, a 
behaviour may access immutable objects and other shared regions.

We refer to behaviours whose regions are overlapping as *overlapping
behaviours*. The runtime guarantees that overlapping behaviours are
serialised.

  **TODO** What about capturing free regions?

Because a ``when`` can operate on any number of shared regions, it
can be used to establish safe synchronous action to different
state at different times (similar to grabbing different sets of
locks, but without risking deadlocks, and with a guarantee that
anything that can be accessed is actually protected by a lock that
has been successfully acquired)::

  my_account = Region()
  your_account = Region()

  with (my_account, your_account):
    my_account.balance = 100
    your_account.balance = 0

  my_account.make_sharable()
  your_account.make_sharable()

  # transfer money between two accounts
  when (my_account, your_account) as (m, y):
    m.balance, y.balance = y.balance, m.balance


Ordering Behaviours
~~~~~~~~~~~~~~~~~~~

The program order of spawns of overlapping behaviours controls the 
happens-before relation between them. In the following example, 
behaviour *b1* is guaranteed to run before *b2* but not before *b3*::

  when (c1, c2):   # b1
    ... 

  when (c2):       # b2
    ...

  when (c3):       # b3, does not overlap with b1 or b2
    ...

To ensure that *b3* does not run before *b1*, we can either introduce
a temporary shared region to make them overlapping::

  c4 = Region().share() # Empty region
  when (c1, c2, c4):   # b1
    ... 

  when (c2):           # b2 -- can run as soon as b1 finishes
    ...

  when (c3, c4):       # b3 -- can run as soon as b1 finishes
    ...


or we can spawn *b3* at the end of *b1*::

  when (c1, c2):   # b1
    ... 
    when (c3):     # b3
      ...

  when (c2):       # b2
    ...

Note that program order refers to order of execution in a single 
behaviour. In the following case, *b2* may run before or after *b4*::

  c = Region("r").share()
  when ():     # b1
    when (c1): # b2
      ...

  when ():     # b3
    when (c1): # b4
      ...


Making a Shared Region Private Again
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  **TODO** Even more WIP!

It is not possible to make a shared region private again. However, it is
possible to spawn a behaviour that, once it has dynamically establised
that is has exclusive access to the share region, moves all its contents
to a private region.

For now, assume that it is possible to call a method
``detach_all()`` on a shared region to create a new private region
that holds all the contents of the shared region, which becomes
empty.

The following code spawns a behaviour that swaps the contents of two
regions::

  when (c1, c2):
    r1, r2 = c1.detach_all(), c2.detach_all()
    c2.field = c2.merge(r1)
    c1.field = c1.merge(r2)



.. _immutable:

Immutable Objects
-----------------

An immutable object's observable state cannot be changed.
(Unobservable state such as its reference count can change.)
An immutable object may only reference other immutable objects.

All attempts to change an immutable object, e.g. a write to a
field, will raise a ``ImmutabilityException``, and the object will
be left unchanged.


Glossary
========

  **Probably out of date now.**

.. _region:

region
  A set of mutable objects including a region object.

.. _private region:

private region
  TODO

.. _region object:

region object
  A single instance of the class ``Region`` that acts as a 
  frontend for a region.

root or root field
  A field in a region object that holds a mutable object in
  the region. Access to a region's root field requires that
  the region is open.

open region
  A region r is open if there is a `with r` block on the 
  stack. An open region can grown (new objects allocated in
  the region), shring (objects in the region are deallocated),
  and read and written.

closed region
  Objects in a closed region are not accessible to the program 
  without first opening the region. 

.. _shared region:

shared region
  TODO

region set
  The set of regions that must be acquired by a behaviour in order
  for it to run.

.. _behaviour:
.. _behaviours:

behaviour
  TODO
  
spawning a behaviours
  TODO

happens-before relation
  TODO

.. _acquire:
.. _release:
.. _releases:

acquire and release 
  A behaviour implicitly acquires all regions in its region set before
  transitioning to the running state. The runtime ensures that
  acquisition is deadlock and livelock free.



Open Questions
==============

- What is the semantics of opening? order? nesting?
- How do we ensure that an object isn't stored in a local variable whose lifetime is longer than the open-scope of its region?
- Merging, freezing and nesting is sound because we only allow a region object to be referenced from one field
- Can an immutable object have a mutable class?
- What about cycles between regions?
- Can we store regions in imms? (I say NO!)
- What is the story for swapping contents of two shared regions
